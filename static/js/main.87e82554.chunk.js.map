{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","tools/placeWall.js","tools/eraseWall.js","tools/movePoints.js","algorithms/greedyBestFirst.js","algorithms/astar.js","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseOut","onMouseUp","row","extraClassName","id","className","Component","placeWall","name","grid","newGrid","slice","node","newNode","eraseWall","MovePoints","greedyBest","startNode","finishNode","visitedNodesInOrder","distance","h","hDistance","unvisitedNodes","nodes","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","nodesInShortestPathOrder","currentNode","unshift","finish","Math","abs","sort","nodeA","nodeB","diff","neighbors","filter","astar","open","priority","getNeighbors","newCost","Dijkstra","updateUnvisitedNeighbors","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","moveTool","Move","wallTool","Wall","PathfindingVisualizer","state","mouseIsPressed","currentTool","algorithm","Dijksta","moveStart","moveEnd","search","onKeyPress","bind","document","getElementById","innerText","getInitialGrid","setState","useTool","classList","contains","startMove","updateSearch","endMove","key","charCode","setTool","i","setTimeout","animateShortestPath","add","resetAnimation","findPath","getNodesInShortestPathOrder","disabled","visited","getElementsByClassName","remove","shortest","resetGridAnimation","animateSearch","newTool","newAlgorithm","onClick","changeAlgorithm","Astar","Greedy","visualizeAlgorithm","resetGrid","Erase","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseOut","handleMouseUp","currentRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.87e82554.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n        col,\r\n        isFinish,\r\n        isStart,\r\n        isWall,\r\n        onMouseDown,\r\n        onMouseEnter,\r\n        onMouseOut,\r\n        onMouseUp,\r\n        row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n        ? 'node-finish'\r\n        : isStart\r\n        ? 'node-start'\r\n        : isWall\r\n        ? 'node-wall'\r\n        : '';\r\n\r\n        return (\r\n            <div\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseOut={() => onMouseOut(row, col)}\r\n            onMouseUp={() => onMouseUp(row, col)}></div>\r\n        );\r\n    }\r\n}","export default class placeWall {\r\n    constructor(){\r\n        this.name = \"Wall Tool\";\r\n    }\r\n    useTool(grid, row, col){\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: true,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n}","export default class eraseWall{\r\n    constructor() {\r\n        this.name = \"Erase Tool\";\r\n    }\r\n    useTool(grid, row, col){\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: false,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n}","export default class MovePoints{\r\n    constructor() {\r\n        this.name = \"Move\";\r\n    }\r\n\r\n    startMove(grid, row, col){\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isStart: !node.isStart,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n\r\n    endMove(grid, row, col){\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isFinish: !node.isFinish,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n}","export default class greedyBest{\r\n  constructor(){\r\n    this.name = \"Greedy Best First Search\"\r\n  }\r\n  \r\n  findPath(grid, startNode, finishNode) {\r\n      const visitedNodesInOrder = [];\r\n      startNode.distance = 0;\r\n      startNode.h = hDistance(startNode, finishNode);\r\n      const unvisitedNodes = getAllNodes(grid);\r\n      while (!!unvisitedNodes.length) {\r\n          sortNodesByDistance(unvisitedNodes);\r\n          const closestNode = unvisitedNodes.shift();\r\n          // If we encounter a wall, we skip it.\r\n          if (closestNode.isWall) continue;\r\n          // If the closest node is at a distance of infinity,\r\n          // we must be trapped and should therefore stop.\r\n          if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n          if (closestNode === finishNode) return visitedNodesInOrder;\r\n          closestNode.isVisited = true;\r\n          visitedNodesInOrder.push(closestNode);\r\n          const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\r\n          for (const neighbor of unvisitedNeighbors) {\r\n              neighbor.previousNode = closestNode;\r\n              const h = hDistance(neighbor, finishNode);\r\n              neighbor.distance = (closestNode.distance + 1 + h)\r\n              neighbor.h = h;\r\n          }\r\n      }\r\n  }\r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the method above.\r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n}\r\n\r\nfunction hDistance(node, finish){\r\n  return (Math.abs(node.col - finish.col) + Math.abs(node.row - finish.row));\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\nunvisitedNodes.sort((nodeA, nodeB) => {\r\n  const diff = nodeA.h - nodeB.h;\r\n  if(diff === 0){\r\n    return nodeA.distance - nodeB.distance;\r\n  }\r\n  return diff;\r\n});\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\nconst neighbors = [];\r\nconst {col, row} = node;\r\nif (row > 0) neighbors.push(grid[row - 1][col]);\r\nif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\nif (col > 0) neighbors.push(grid[row][col - 1]);\r\nif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\nreturn neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\nconst nodes = [];\r\nfor (const row of grid) {\r\n  for (const node of row) {\r\n    nodes.push(node);\r\n  }\r\n}\r\nreturn nodes;\r\n}","export default class astar{\r\n  constructor(){\r\n    this.name = \"A* Algorithm\"\r\n  }\r\n  \r\n  findPath(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    startNode.h = hDistance(startNode, finishNode);\r\n    const open = [];\r\n    open.push(startNode);\r\n    while (!!open.length) {\r\n        sortNodesByDistance(open);\r\n        const closestNode = open.shift();\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        const neighbors = getNeighbors(closestNode, grid);\r\n        for (const neighbor of neighbors) {\r\n            let newCost = closestNode.distance + 1;\r\n            if(neighbor.distance === Infinity || neighbor.distance > newCost){\r\n                neighbor.distance = newCost;\r\n                neighbor.previousNode = closestNode;\r\n                const h = hDistance(neighbor, finishNode);\r\n                neighbor.priority = h + newCost;\r\n                neighbor.h = h;\r\n                open.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n    \r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n}\r\n\r\nfunction hDistance(node, finish){\r\n  return (Math.abs(node.col - finish.col) + Math.abs(node.row - finish.row));\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => {\r\n    const diff = nodeA.priority - nodeB.priority;\r\n\r\n    if(diff === 0){\r\n      return nodeA.h - nodeB.h;\r\n    }\r\n    \r\n    return diff;\r\n  });\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport default class Dijkstra{\r\n  constructor(){\r\n    this.name = \"Dijkstra's Algorithm\"\r\n  }\r\n  \r\n  findPath(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {Wall, Erase, Move} from '../tools/tools';\r\nimport {Greedy, Astar, Dijksta} from '../algorithms/algorithms.js';\r\nimport './PathfindingVisualizer.css';\r\n\r\nvar START_NODE_ROW = 10;\r\nvar START_NODE_COL = 15;\r\nvar FINISH_NODE_ROW = 10;\r\nvar FINISH_NODE_COL = 35;\r\nconst moveTool = new Move();\r\nconst wallTool = new Wall();\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n        grid: [],\r\n        mouseIsPressed: false,\r\n        currentTool: new Wall(),\r\n        algorithm: new Dijksta(),\r\n        moveStart: false,\r\n        moveEnd: false,\r\n        search: false,\r\n        };\r\n        this.onKeyPress = this.onKeyPress.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.getElementById(\"currentTool\").innerText = \"Current Tool: \" + this.state.currentTool.name;\r\n        const grid = getInitialGrid();\r\n        this.setState({grid});\r\n    }\r\n\r\n    \r\n\r\n    handleMouseDown(row, col) {\r\n        if(row === START_NODE_ROW && col === START_NODE_COL){\r\n            this.setState({moveStart: true});\r\n        }else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\r\n            this.setState({moveEnd: true});\r\n        }else{\r\n            const currentTool = this.state.currentTool;\r\n            const newGrid = currentTool.useTool(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n        }\r\n        this.setState({mouseIsPressed: true});\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        if(this.state.moveStart && !(document.getElementById(`node-${row}-${col}`).classList.contains(\"node-wall\"))){\r\n            START_NODE_ROW = row;\r\n            START_NODE_COL = col;\r\n            const newGrid = moveTool.startMove(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n            if(this.state.search === true){\r\n                this.updateSearch();\r\n            }\r\n        }else if(this.state.moveEnd && !document.getElementById(`node-${row}-${col}`).classList.contains(\"node-wall\")){\r\n            FINISH_NODE_ROW = row;\r\n            FINISH_NODE_COL = col;\r\n            const newGrid = moveTool.endMove(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n            if(this.state.search === true){\r\n                this.updateSearch();\r\n            }\r\n        }else{\r\n            const currentTool = this.state.currentTool;\r\n            const newGrid = currentTool.useTool(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n        }\r\n    }\r\n\r\n    handleMouseOut(row, col) {\r\n        if(this.state.moveStart && !document.getElementById(`node-${row}-${col}`).classList.contains(\"node-wall\")){\r\n            const newGrid = moveTool.startMove(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n        }else if(this.state.moveEnd && !document.getElementById(`node-${row}-${col}`).classList.contains(\"node-wall\")){\r\n            const newGrid = moveTool.endMove(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        this.setState({mouseIsPressed: false, moveStart: false, moveEnd: false});\r\n    }\r\n\r\n    onKeyPress(key){\r\n        if(key.charCode === 77){\r\n            this.setTool(wallTool);\r\n        }\r\n    }\r\n\r\n    animateSearch(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n            setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n            }, 10 * i);\r\n            return;\r\n        }\r\n        setTimeout(() => {\r\n            const node = visitedNodesInOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-visited\");\r\n        }, 10 * i);\r\n        }\r\n    }\r\n\r\n    updateSearch() {\r\n        this.resetAnimation();\r\n        const {grid, algorithm} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = algorithm.findPath(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = algorithm.getNodesInShortestPathOrder(finishNode);\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n            break;\r\n        }\r\n            const node = visitedNodesInOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-visited\");\r\n        }\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-shortest-path\");\r\n            }\r\n    }\r\n\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-shortest-path\");\r\n        }, 50 * i);\r\n        }\r\n        document.getElementById(\"reset\").disabled = false;\r\n    }\r\n\r\n    resetGrid(){\r\n        const newGrid = getInitialGrid();\r\n        this.setState({grid: newGrid});\r\n        for (let row = 0; row < 20; row++) {\r\n            for (let col = 0; col < 50; col++) {\r\n                if (row === START_NODE_ROW && col === START_NODE_COL){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\r\n                } else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\r\n                }else{\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        this.setState({search: false});\r\n    }\r\n\r\n    resetAnimation(){\r\n        const visited = document.getElementsByClassName(\"node-visited\");\r\n        while(visited.length !== 0){\r\n            visited[0].classList.remove(\"node-visited\");\r\n        }\r\n        const shortest = document.getElementsByClassName(\"node-shortest-path\");\r\n        while(shortest.length !== 0){\r\n            shortest[0].classList.remove(\"node-shortest-path\");\r\n        }\r\n        resetGridAnimation(this.state.grid);\r\n    }\r\n\r\n    visualizeAlgorithm() {\r\n        this.resetAnimation();\r\n        this.setState({search: true});\r\n        document.getElementById(\"reset\").disabled = true;\r\n        const {grid, algorithm} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = algorithm.findPath(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = algorithm.getNodesInShortestPathOrder(finishNode);\r\n        this.animateSearch(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    setTool(newTool){\r\n        this.setState({currentTool: newTool});\r\n        document.getElementById(\"currentTool\").innerText = \"Current Tool: \" + newTool.name;\r\n    }\r\n\r\n    changeAlgorithm(newAlgorithm){\r\n        this.setState({algorithm: newAlgorithm});\r\n        this.resetAnimation();\r\n        document.getElementById(\"startVisualization\").innerText = \"Visualize \" + newAlgorithm.name;\r\n    }\r\n\r\n    render() {\r\n        const {grid, mouseIsPressed} = this.state;\r\n\r\n        return (\r\n        <>\r\n                <nav>\r\n                    <div className=\"dropdown\">\r\n                        <div className=\"algorithms\">\r\n                            <button className=\"btn\">Algorithms</button>\r\n                            <ul>\r\n                                <li><button onClick={() => this.changeAlgorithm(new Dijksta())}>Dijkstra's</button></li>\r\n                                <li><button onClick={() => this.changeAlgorithm(new Astar())}>A*</button></li>\r\n                                <li><button onClick={() => this.changeAlgorithm(new Greedy())}>Greed Best First</button></li>\r\n                            </ul>\r\n                        </div>\r\n                        <button id = \"startVisualization\" className=\"btn\" onClick={() => this.visualizeAlgorithm()}>\r\n                            Visualize Dijkstra's Algorithm\r\n                        </button>\r\n                        <button id = \"reset\" className=\"btn\" onClick={() => this.resetGrid()}>\r\n                            Reset\r\n                        </button>\r\n                        <button id = \"placeWalls\" className=\"btn\" onClick={() => this.setTool(new Wall())}>\r\n                            Place Walls\r\n                        </button>\r\n                        <button id = \"eraseWalls\" className=\"btn\" onClick={() => this.setTool(new Erase())}>\r\n                            Erase Walls\r\n                        </button>\r\n                        <span id = \"currentTool\">Current Tool: </span>\r\n                    </div>\r\n                </nav>\r\n                <div className=\"grid\" onKeyPress={this.onKeyPress}>\r\n                {grid.map((row, rowIdx) => {\r\n                    return (\r\n                    <div key={rowIdx}>\r\n                        {row.map((node, nodeIdx) => {\r\n                        const {row, col, isFinish, isStart, isWall} = node;\r\n                        return (\r\n                            <Node\r\n                            key={nodeIdx}\r\n                            col={col}\r\n                            row={row}\r\n                            isFinish={isFinish}\r\n                            isStart={isStart}\r\n                            isWall={isWall}\r\n                            mouseIsPressed={mouseIsPressed}\r\n                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                            onMouseOut={(row, col) => this.handleMouseOut(row,col)}\r\n                            onMouseUp={() => this.handleMouseUp(row, col)}></Node>\r\n                        );\r\n                        })}\r\n                    </div>\r\n                    );\r\n                })}\r\n                </div>\r\n        </>\r\n        );\r\n    }\r\n}\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 50; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst resetGridAnimation = (grid) => {\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            let node = grid[row][col];\r\n            grid[row][col] = {...node, distance: Infinity, isVisited: false, previousNode: null, h: Infinity, priority: Infinity,};\r\n        }\r\n    }\r\n    return grid\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n        h: Infinity,\r\n        priority: Infinity,\r\n    };\r\n};\r\n\r\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}